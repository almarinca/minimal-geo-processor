# üó∫Ô∏è Geo Processor Microservice Ecosystem

A minimal Geo-Processor web app that accepts a list of geographic coordinates (latitude/longitude), computes their bounding box (north, south, east, west) and centroid, and displays the result visually on a interactive world map.

![demo-img](https://github.com/user-attachments/assets/b1c28d15-3617-4b2e-bdf7-f3a8ef7b5c93)

## üì¶ Overview

This project is a very simple full-stack microservice-based system built for demonstration purposes. It processes and visualizes geographic coordinates through a three-tier architecture:

* **Python (FastAPI) microservice:** The backend for geographic computation
* **NestJS middleware service:** Acts as an API gateway, handles validation, caching, and request forwarding
* **Next.js frontend:** Web UI that allows users to input coordinates and visualize results on a interactive map

The ecosystem is containerized using Docker and orchestrated via `docker compose`.

## üß∞ Technology Stack

* **Backend**: Python, FastAPI, Pydantic
* **Gateway**: NestJS, Axios, class-validator, class-transformer, cache-manager
* **Frontend**: Next.js, React, react-simple-maps, Axios, TanStack Query
* **Containerization**: Docker, Docker Compose

## ‚öôÔ∏è Installation & Setup

### Prerequisites

* Docker
* Docker Compose
* (Optional) Make ‚Äì for using the provided Makefile

### Running the Application

If you want to test the application locally in a development enviroment, then clone this repository, navigate to its root directory and then run:

```bash
make up
```

Alternatively, if you don`t have Make installed or you just prefer to use docker compose directly, you can run:

```bash
docker compose up --build
```

To shut down:

```bash
make down
```
Or:

```bash
docker compose down
```

The default urls that are set in the compose file are:

- **Frontend**: `http://localhost:3000`
- **Gateway API**: `http://localhost:3001/geo/summary`
- **Backend API**: `http://localhost:8000/geo/summary`

You just need to open the frontend in your browser to interact with the app:

**Frontend**: http://localhost:3000

You can also interact directly with the backend through the swagger documentation UI auto-generated by FastAPI:

**Backend API Swagger Documentation**: http://localhost:8000/docs

## üß† Design Decisions

- **End-to-End DTO Validation:** Strong schema across services.
Input is validated in the frontend form, in the gateway, and again in the backend for redundancy and proper user feedback.
Pydantic in Python and Class Validator in NestJS act as DTOs to provide strong runtime safety.

- **Response Validation in Gateway**: Checking that backend data matches expected DTO shape avoids leaking malformed or invalid backend responses to clients.

- **DTO DRY**: In all services, either by reusable Validation Decorators and or model inheritance, to improve clarity and reusability across different DTOs.

- **HTTP Requests:** Axios is used both in the frontend and the gateway middleware for easy HTTP handling. Axios was chosen for its ease of use and its built-in capabilities (e.g., automatic JSON parsing, request cancellation, error handling).

- **Caching:** In-memory caching in the NestJS API Gateway is implemented using Cache Manager, chosen for its easy-to-use plugability with NestJS. In-memory caching was considered sufficient for this small demo, although a persistent cache layer is planned as a future improvement.

- **Caching with Hash-Based Keys:** Used a SHA-256 hash of a sorted JSON string of the body. Allowing that identical payloads produce the same cache key and avoiding redundant backend calls.

- **Stateless Backend:** The Python service is completely stateless. Caching is performed at the NestJS layer.

- **Environment Configuration:** Dedicated config module to centralize the access to enviroment configuration variables, and avoid hardcoded values.

- **Separation of concerns:** Internally, each service was separated roughly following an MVCS pattern and the conventions of the frameworks used (FastAPI, NestJS), with DTOs or Schemas for data definition, a controller (or router) for HTTP routing, and service modules for handling the actual service logic. Also, centralized utility functions were placed in separate modules to avoid mixing responsibilities. This helps keep services focused, promotes reuse, and avoids duplication.

- **Frontend Data Fetching:** TanStack Query was chosen for state management and data synchronization in the React frontend. It was selected to minimize boilerplate, improve performance, and provide an easy-to-use declarative interface.

- **Map Rendering:** react-simple-maps was used for its simplicity and developer-friendly design, allowing quick prototyping of applications like this using interactive geographic maps based on GeoJSON data rendered through SVGs.


## üîú Future Improvements

* Add persistent cache (e.g., Redis) to replace in-memory caching
* Use share DTOs/schemas for a centralized handling, and better ensure backend contracts are upheld.
* Add tests: unit and integration
* Deploy services to a cloud provider
* Add support for uploading large coordinate files (e.g. csv)
* CI/CD pipeline (GitHub Actions)
* Enhance map UX: zoom, drag, entered point markers, display cursor coordinates, add a new point when clicking on the map
* Add user-friendly error messages on the frontend
* Add loading UI (e.g., a spinner)
* Add more geographical statistics on the summary endpoint
* Additional geographical operations (e.g. you current location, distance between coordinates)

## üìå API Specification

### `POST /geo/summary`

Computes a geographic **centroid** and **bounding box** from a list of latitude/longitude coordinate points.

---

### Request

**Content Type:** `application/json`

#### Example:
```json
{
  "points": [
    { "lat": 40.7128, "lng": -74.006 },
    { "lat": 34.0522, "lng": -118.2437 }
  ]
}
```

#### Schema

- `points`: array&lt;object&gt;
  - `lat`: float ‚àà [-90, 90]
  - `lng`: float ‚àà [-180, 180]


### Successful Response

**Status Code:** `200 OK`  
**Content Type:** `application/json`

#### Example:
```json
{
  "centroid": { "lat": 37.3825, "lng": -96.1248 },
  "bounds": {
    "north": 40.7128,
    "south": 34.0522,
    "east": -74.006,
    "west": -118.2437
  }
}
```

#### Schema:
- `centroid`
  - `lat`: float ‚àà [-90, 90]
  - `lng`: float ‚àà [-180, 180]
- `bounds`
  - `north`, `south`: float ‚àà [-90, 90]
  - `east`, `west`: float ‚àà [-180, 180]

---

### Error Responses

#### `422 Unprocessable Entity` ‚Äì Validation Errors

Example:
```json
{
  "detail": [
    {
      "loc": [
        "string",
        0
      ],
      "msg": "string",
      "type": "string"
    }
  ]
}
```

#### `404 Not Found` ‚Äì Server cannot find the requested enpoint resource

Example:
```json
{
    "message": "string",
    "error": "Not Found",
    "statusCode": 404
}
```

#### `400 Bad Request` ‚Äì Malformed request syntax or corrupted data

Example:
```json
{
  {
    "message": [
        "string",
    ],
    "error": "Bad Request",
    "statusCode": 400
}
}
```

#### `502 Bad Gateway` ‚Äì Invalid response received from the backend server

Example:
```json
{
    "statusCode": 502,
    "message": "string"
}
```

#### `500 Internal Server Error` ‚Äì Something went wrong on the gateway server

Example:
```json
{
    "statusCode": 500,
    "message": "string"
}
```

### Example `curl` Request

```bash
curl -X POST http://localhost:3001/geo/summary \
  -H "Content-Type: application/json" \
  -d '{
        "points": [
          { "lat": 40.7128, "lng": -74.006 },
          { "lat": 34.0522, "lng": -118.2437 }
        ]
      }'
```
